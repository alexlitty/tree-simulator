#include <tree/Component/Physical.hpp>
#include <tree/Math/Constant.hpp>
#include <tree/Math/Geometry.hpp>
#include <tree/Math/Vector.hpp>

// @@@@@
#include <iostream>

// Constructor.
tree::Physical::Physical()
: m_rotation(0),
  mass(0),
  rotationSpeed(0),
  rotationSpeedMax(0),
  rotationAcceleration(0)
{
    boundary.transform = &m_physicalTransform.getTransform();
}

// Retrieves the graphical transformation caused by physics.
const sf::Transform& tree::Physical::getPhysicalTransform() const
{
    return m_physicalTransform.getTransform();
}

// Allows time to pass, letting physics change this object.
void tree::Physical::passTime(float seconds, std::vector<Physical*>& objects)
{
    sf::Vector2f gravity;
    float force, magnitude, distance;

    // Perform rotation.
    rotationSpeed += rotationAcceleration * seconds;
    rotate(rotationSpeed);

    // Gravitational influences.
    for (uint32_t i = 0; i < objects.size(); i++) {
        Physical* object = objects[i];

        // Don't influence self.
        if (object == this) {
            continue;
        }

        // Gravitational pull.
        if (mass > 0 && object->mass > 0) {

            // Calculate force generated by other object.
            distance = Math::distance(getPosition(), object->getPosition());
            force = (Math::GRAVITATIONAL * mass * object->mass);
            force /= std::pow(distance, 2);
            magnitude = force / mass;

            // Pull towards other object.
            gravity = Math::setMagnitude(
                object->getPosition() - getPosition(),
                magnitude);
            accelerate(gravity);
        }
    }
    
    // Perform acceleration.
    velocity += acceleration * seconds;
    acceleration = tree::Math::Vector::ZERO;

    // Move the object while resolving collisions.
    boundary.update();
    resolveCollisions(seconds, objects);
}
#include <iostream>
// Resolve collisions on this object.
void tree::Physical::resolveCollisions(float seconds, std::vector<Physical*>& objects)
{
    std::vector<Physical*> collisions;
    Physical *nearestCollisionObject = nullptr;
    float collisionDistance, nearestCollisionDistance = -1;
    sf::Vector2f collisionPoint, nearestCollisionPoint;

    // Determine the trajectory of this object.
    sf::Vector2f start = getPosition();
    sf::Vector2f delta = velocity * seconds;
    sf::Vector2f end = start + delta;

    for (unsigned int i = 0; i < objects.size(); i++) {

        if (objects[i] == this) {
            continue;
        }

        // Find collisions against the trajectory.
        if (objects[i]->boundary.collides(start, end, collisionPoint)) {

            // Debug point upon collision.
            sf::Vertex temp(collisionPoint, sf::Color::Yellow);
            debug.append(temp);
            debug.setPrimitiveType(sf::Points);

            // Look for the nearest collision.
            collisionDistance = Math::distance(start, collisionPoint);
            if (nearestCollisionDistance == -1 || collisionDistance < nearestCollisionDistance) {
                nearestCollisionDistance = collisionDistance;
                nearestCollisionPoint = collisionPoint;
                nearestCollisionObject = objects[i];
            }
        }
    }

    // No collision.
    if (nearestCollisionObject == nullptr) {
        move(delta);
    }

    // Or, perform physics for this collision, and pass remaining time.
    else {
    }
}

// Gets position.
sf::Vector2f tree::Physical::getPosition() const
{
    return m_position;
}

// Sets position.
void tree::Physical::setPosition(sf::Vector2f& position)
{
    m_position = position;
    m_physicalTransform.setPosition(position);
}

// Move this object relative to its current position.
void tree::Physical::move(sf::Vector2f& vector)
{
    sf::Vector2f result = getPosition() + vector;
    setPosition(result);
}

// Queue this object for acceleration.
void tree::Physical::accelerate(sf::Vector2f& vector)
{
    acceleration += vector;
}

// Gets rotation.
float tree::Physical::getRotation() const
{
    return m_rotation;
}

// Sets rotation.
void tree::Physical::setRotation(float magnitude)
{
    m_rotation = magnitude;
    m_physicalTransform.setRotation(magnitude);
}

// Perform rotation.
void tree::Physical::rotate(float magnitude)
{
    setRotation(getRotation() + magnitude);
}
